# Kodr Prep: Data Structures & Algorithms
1. [Introduction & Course Objectives](1.md)

    1.1. Overview of the Course
        Why these data structures and algorithms matter for coding interviews.
        How mastering them will elevate your problem-solving skills in real-world engineering.
    1.2. Learning Goals & Outcomes
        Build familiarity and confidence with each data structure.
        Develop strong algorithmic thinking for common coding challenges.
        Gain the ability to evaluate space/time trade-offs for different approaches.

2. [Slices, Strings, and Runes](2.md)

    2.1. Fundamentals
        Difference between arrays, slices, and lists.
        Introduction to string segmentation and slicing operations.
    2.2. Memory Layout & Performance
        How slices reference underlying arrays.
        Common pitfalls when working with shared references.
    2.3. Working with Unicode & Runes
        Why runes exist and how they relate to character encoding.
        Handling multi-byte characters and common edge cases.

3. [Hashmaps and Sets](3.md)

    3.1. Concepts & Internals
        Key ideas behind hashing and collision resolution.
        Typical implementations of hashmaps and sets.
    3.2. Time & Space Complexities
        Average vs. worst-case scenarios for insert, delete, and lookup.
    3.3. Memory Management & Collision Strategies
        Chaining vs. open addressing.
        Practical considerations in language-specific standard libraries.

4. [Stacks, Heaps, and Queues](4.md)

    4.1. Stack
        LIFO principle and key operations (push, pop, peek).
        Implementation strategies and use cases (DFS, function call stacks).
    4.2. Heap
        Priority queues and the concept of a min-heap/max-heap.
        Heapify operations and typical library implementations.
    4.3. Queue
        FIFO principle and key operations (enqueue, dequeue).
        Circular queues and deque structures.

5. [Trees and Graphs](5.md)

    5.1. Trees
        Terminology (root, leaf, height, etc.) and basic traversals.
        Binary Trees vs. Binary Search Trees (BST).
        Balanced trees (AVL, Red-Black) overview.
    5.2. Graphs
        Directed vs. undirected graphs.
        Representations (adjacency list vs. adjacency matrix).
        Traversal algorithms (DFS and BFS).

6. [Search Algorithms](6.md)

    6.1. Linear & Binary Search
        Linear scan complexities and optimization.
        Binary search prerequisites and variations.
    6.2. Graph & Tree Search
        Depth-First Search in detail (recursive vs. iterative).
        Breadth-First Search and shortest-path introduction.
    6.3. Advanced Searching Techniques
        A* search basics or Dijkstraâ€™s Algorithm for graphs.
        Heuristics and real-world applications.

7. [Practice & Problem-Solving Strategies](7.md)

    7.1. Common Coding Interview Patterns
        Sliding window, two pointers, sorting-based, and backtracking patterns.
    7.2. Mock Interview Exercises
        Timed practice sessions.
        Behavioral questions overview.
    7.3. Optimization & Trade-Offs
        Recognizing time vs. space complexity trade-offs.
        Approaches to handle edge cases and large inputs.